<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8">
    <title>WebAudio Test</title>
    <meta name="description" content="WebAudio Test">
    <meta name="author" content="Simon Guest">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="main.css">
    <script src="./lib/blockly.min.js"></script>
</head>

<body>
<table>
    <tr>
        <td>
            <button id="play">Play</button>
            <button id="pause">Pause</button>
            <button id="resume">Resume</button>
            <button id="stop">Stop</button>
            <button id="debug">Debug</button>
            <button id="clear">Clear Workspace</button>
            <select id="examples">
                <option value="" selected="true">Example Workspaces...</option>
                <option value="bliss.json">Bliss (Mike Harvey)</option>
                <option value="synth-groove.json">Synth Groove (Sanchit Malhotra)</option>
                <option value="dual.json">Dual Tracks</option>
                <option value="filter.json">Low Pass Filter</option>
                <option value="pitch.json">Single Voice Pitch</option>
            </select>
            <button id="export">Export Workspace</button>
            <input type="file" id="import"/>
        </td>
    </tr>
    <tr>
        <td id="blocklyArea">
            Loading workspace...
        </td>
    </tr>
</table>
<div id="blocklyDiv" style="position: absolute"></div>

<script type="module">
    const createCustomBlock = (name, blockType) => {
        Blockly.Blocks[name] = blockType;
        Blockly.JavaScript[name] = blockType["transpile"];
    }

    import {notes} from "./notes.js";

    import * as control from "./blocks/control/index.js";
    import * as percussion from "./blocks/percussion/index.js";
    import * as looping from "./blocks/looping/index.js";
    import * as effects from "./blocks/effects/index.js";
    import * as synths from "./blocks/synths/index.js";

    import {toolbox} from "./blocks/toolbox.js";

    createCustomBlock("track", control.track);
    createCustomBlock("playNote", control.playNote);
    createCustomBlock("playNoteUntilEnd", control.playNoteUntilEnd);
    createCustomBlock("playChord", control.playChord);
    createCustomBlock("playChordUntilEnd", control.playChordUntilEnd);
    createCustomBlock("playPianoKey", control.playPianoKey);
    createCustomBlock("playPianoKeyUntilEnd", control.playPianoKeyUntilEnd);
    createCustomBlock("playSample", control.playSample);
    createCustomBlock("playSampleUntilEnd", control.playSampleUntilEnd);
    createCustomBlock("sleep", control.sleepSeconds);
    createCustomBlock("sleepBeats", control.sleepBeats);
    createCustomBlock("volume", control.volume);
    createCustomBlock("pitch", control.pitch);
    createCustomBlock("filter", control.filter);
    createCustomBlock("bpm", control.bpm);

    createCustomBlock("snare", percussion.snare);
    createCustomBlock("kick", percussion.kick);
    createCustomBlock("hihat", percussion.hihat);
    createCustomBlock("techno", looping.techno);

    createCustomBlock("choir", effects.choir);

    createCustomBlock("setSynth", synths.setSynth);
    createCustomBlock("mystic", synths.mystic);
    createCustomBlock("pluck", synths.pluck);
    createCustomBlock("piano", synths.piano);
    createCustomBlock("violin", synths.violin);
    createCustomBlock("customSynth", synths.customSynth);

    let blocklyArea = document.getElementById('blocklyArea');
    let blocklyDiv = document.getElementById('blocklyDiv');
    let workspace = Blockly.inject('blocklyDiv', {
        toolbox: toolbox,
        horizontalLayout: false,
        toolboxPosition: "start",
        move: {
            scrollbars: {
                horizontal: false,
                vertical: true
            },
            drag: true,
            wheel: true
        },
        trashcan: false
    });
    let onresize = function () {
        // Compute the absolute coordinates and dimensions of blocklyArea.
        let element = blocklyArea;
        let x = 0;
        let y = 0;
        do {
            x += element.offsetLeft;
            y += element.offsetTop;
            element = element.offsetParent;
        } while (element);
        // Position blocklyDiv over blocklyArea.
        blocklyDiv.style.left = x + 'px';
        blocklyDiv.style.top = y + 'px';
        blocklyDiv.style.width = blocklyArea.offsetWidth + 'px';
        blocklyDiv.style.height = blocklyArea.offsetHeight + 'px';
        Blockly.svgResize(workspace);
    };
    window.addEventListener('resize', onresize, false);
    onresize();
    Blockly.svgResize(workspace);

    workspace.addChangeListener((ev) => {
        if ((ev.type === Blockly.Events.BLOCK_MOVE) || (ev.type === Blockly.Events.BLOCK_CHANGE) || (ev.type === Blockly.Events.BLOCK_DELETE) || (ev.type === Blockly.Events.BLOCK_CREATE)) {
            console.log("Writing workspace to session storage");
            let json = Blockly.serialization.workspaces.save(workspace);
            sessionStorage.setItem("workspace", JSON.stringify(json));
        }
    });

    const loadFile = async (filename) => {
        const response = await fetch(filename);
        if (!response.ok) {
            console.error(`HTTP Error: ${response.status}`);
        }
        return await response.arrayBuffer();
    }

    const loadSamples = async (audioContext, samples, filenames) => {
        return new Promise(async (resolve) => {
            for (let f = 0; f < filenames.length; f++) {
                if (!samples.get(filenames[f])) {
                    let buffer = await loadFile(`./samples/${filenames[f]}.wav`);
                    let decodedBuffer = await audioContext.decodeAudioData(buffer);
                    samples.set(filenames[f], decodedBuffer);
                    console.log(`Loaded audio sample ${filenames[f]}`);
                }
            }
            resolve(samples);
        });
    }

    const findSamplesInWorkspace = (workspace) => {
        let sampleFilesRe = /"SAMPLE_FILE".?:.?"(?<filename>.*?)"/mg
        let matches = [];
        let match = sampleFilesRe.exec(workspace);
        do {
            if (match) matches.push(match.groups.filename);
        } while ((match = sampleFilesRe.exec(workspace)) !== null)
        return [...new Set(matches)];
    }

    const convertToUnitInterval = (value) => {
        // Convert value to fixed point between 0 and 1 for the WebAudio API
        value = Math.abs(value);
        if (value > 100) value = 100;
        return value / 100;
    }

    const highlightBlock = (id) => {
        document.evaluate(`//*[@data-id='${id}']`, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue.classList.add("blocklySelected")
    }

    const removeHighlight = (id) => {
        document.evaluate(`//*[@data-id='${id}']`, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue.classList.remove("blocklySelected")
    }

    const buildGainNodeFromEnvelope = (context, options) => {
        let volume = options.volume || 100;
        const DEFAULT_SYNTH = {
            wave: "triangle",
            adsr: {
                attackLevel: 0.8,
                attackDuration: 0.01,
                decayLevel: 0.35,
                decayDuration: 0.1,
                sustainDuration: 0.1,
                releaseDuration: 0.3
            }
        }
        let synth = options.synth || DEFAULT_SYNTH;
        let attackLevel = synth.adsr.attackLevel * (volume / 100);
        let attackDuration = synth.adsr.attackDuration;
        let decayLevel = synth.adsr.decayLevel * (volume / 100);
        let decayDuration = synth.adsr.decayDuration;
        let sustainDuration = synth.adsr.sustainDuration;
        let releaseDuration = synth.adsr.releaseDuration;
        let totalDuration = 0;

        let gainNode = context.createGain();
        gainNode.gain.setValueAtTime(0, 0 + context.currentTime + options.offset);
        totalDuration += attackDuration;
        gainNode.gain.linearRampToValueAtTime(attackLevel, totalDuration + context.currentTime + options.offset);
        totalDuration += decayDuration;
        gainNode.gain.linearRampToValueAtTime(decayLevel, totalDuration + context.currentTime + options.offset);
        totalDuration += sustainDuration;
        gainNode.gain.setValueAtTime(decayLevel, totalDuration + context.currentTime + options.offset);
        totalDuration += releaseDuration;
        gainNode.gain.linearRampToValueAtTime(0, totalDuration + context.currentTime + options.offset);

        return {gainNode: gainNode, duration: totalDuration};
    }

    const buildNodeTree = (context, sourceNode, duration, options, blockid) => {
        let volume = options.volume || 100;
        let filter = options.filter || 100;
        let offset = options.offset || 0;

        // highlight the active block
        // null src is an empty source used to highlight the block
        // (to compensate as there is no onStart event handler in WebAudio AudioBufferSourceNode )
        let nullSource = context.createBufferSource();
        if (blockid) {
            sourceNode.onended = () => {
                removeHighlight(blockid);
            }

            nullSource.connect(context.destination);
            nullSource.buffer = context.createBuffer(1, 1, 10000);
            nullSource.onended = () => {
                highlightBlock(blockid);
            }
        }

        // Build the tree backwards, starting with the gain node for volume
        let gainNode;
        if (sourceNode.buffer) {
            // gainnode should be constant level to playback the buffer
            gainNode = context.createGain();
            gainNode.gain.value = convertToUnitInterval(volume)
        } else {
            // gainnode should follow the ADSR envelope defined in the synth
            let output = buildGainNodeFromEnvelope(context, options);
            gainNode = output.gainNode;
            if (output.duration > duration) duration = output.duration;
        }
        gainNode.connect(context.destination);

        // Add the filter node
        let filterNode = context.createBiquadFilter();
        filterNode.frequency.value = 44000;
        if (sourceNode.buffer) {
            filterNode.type = "lowpass";
            filterNode.frequency.value = (sourceNode.buffer.sampleRate / 4) * convertToUnitInterval(filter);
        }
        filterNode.connect(gainNode);
        sourceNode.connect(filterNode);

        // start the source and null source
        sourceNode.start(offset + context.currentTime);
        nullSource.start(offset + context.currentTime);
        if (duration) {
            sourceNode.stop(context.currentTime + offset + duration);
        }

    }

    const playSample = (context, samples, name, options, blockid) => {
        let src = context.createBufferSource();
        src.buffer = samples.get(name);
        src.playbackRate.value = options.pitch || 1;

        buildNodeTree(context, src, null, options, blockid);

        return src.buffer.duration; // used for play sample until end block
    }

    const playNote = (context, note, duration, options, blockid) => {
        let osc = context.createOscillator();
        osc.type = "triangle";
        if (options.synth) {
            osc.type = options.synth.wave;
        }
        if (note.freq) {
            osc.frequency.value = note.freq;
        }
        if (note.key) {
            osc.frequency.value = notes[note.key + 8][1]; //offset for an 88 key piano
        }

        buildNodeTree(context, osc, duration, options, blockid);
    }

    const playChord = (context, notes, duration, options, blockid) => {
        switch (options.arpeggio) {
            case "all":
                notes.forEach(note => playNote(context, note, duration, options, blockid));
                break;
            case "up":
                notes.forEach(note => {
                    playNote(context, note, duration / notes.length, options, blockid);
                    sleep(context, duration / notes.length, options, blockid);
                });
                options.offset -= duration;
                break;
            case "down":
                notes.reverse().forEach(note => {
                    playNote(context, note, duration / notes.length, options, blockid);
                    sleep(context, duration / notes.length, options, blockid);
                });
                options.offset -= duration;
                break;
            case "random":
                let randomNotes = notes.map(value => ({value, sort: Math.random()}))
                    .sort((a, b) => a.sort - b.sort)
                    .map(({value}) => value);
                randomNotes.forEach(note => {
                    playNote(context, note, duration / notes.length, options, blockid);
                    sleep(context, duration / notes.length, options, blockid);
                });
                options.offset -= duration;
                break;
            default:
                notes.forEach(note => playNote(context, note, duration, options, blockid));
        }

    }

    const sleep = (context, duration, options, blockid) => {
        // Create a blank sleep source at 10Khz
        let sleepSource = context.createBufferSource();
        sleepSource.connect(context.destination);
        sleepSource.buffer = context.createBuffer(1, duration * 10000, 10000);

        buildNodeTree(context, sleepSource, duration, options, blockid);
        options.offset += duration;
    }


    async function start() {
        console.log("Loading workspace from session storage");
        let jsonStr = sessionStorage.getItem("workspace");
        if (jsonStr) Blockly.serialization.workspaces.load(JSON.parse(jsonStr), workspace);

        let context = new window.AudioContext();

        let samples = new Map();

        document.getElementById("play").onclick = async () => {
            console.log("play button pressed");

            // Dynamically load the sample wav files required by the workspace
            samples = await loadSamples(context, samples, findSamplesInWorkspace(sessionStorage.getItem("workspace")));

            // Generate the required code
            let code = Blockly.JavaScript.workspaceToCode(workspace);
            console.log(code);

            context = new window.AudioContext();
            var options = {bpm: 100, offset: 0};
            eval(code);
        }

        document.getElementById("pause").onclick = () => {
            console.log("pause button pressed");
            context.suspend();
        }

        document.getElementById("resume").onclick = () => {
            console.log("resume button pressed");
            context.resume();
        }

        document.getElementById("stop").onclick = () => {
            console.log("stop button pressed");
            context.close();
        }

        document.getElementById("debug").onclick = () => {
            console.log("debug button pressed");
            context = new window.AudioContext();
            playSample(context, samples, "snare", {});
            playSample(context, samples, "snare", {offset: 0.5});
        }

        document.getElementById("clear").onclick = () => {
            console.log("clear session button pressed");
            if (confirm("Clearing the workspace will lose all unsaved work. Continue?")) {
                sessionStorage.removeItem("workspace");
                location.reload();
            }
        }
        document.getElementById("examples").value = "";
        document.getElementById("examples").onchange = async (e) => {
            console.log("example workspace changed");
            if (e.target.value) {
                if (confirm("Loading this example workspace will lose all unsaved work. Continue?")) {
                    const response = await fetch(`./examples/${e.target.value}`);
                    const json = await response.json();
                    Blockly.serialization.workspaces.load(json, workspace);
                }
            }
        }

        document.getElementById("export").onclick = () => {
            console.log("export workspace button pressed");
            let file = new Blob([sessionStorage.getItem("workspace")], {type: "text/json"});
            let a = document.createElement("a"),
                url = URL.createObjectURL(file);
            a.href = url;
            a.download = "musiclab-workspace.json";
            document.body.appendChild(a);
            a.click();
            setTimeout(function () {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 0);
        }

        document.getElementById("import").onchange = (e) => {
            console.log("importing workspace from file");
            let file = e.target.files[0];
            if (!file) {
                return;
            }
            let reader = new FileReader();
            reader.onload = function (e) {
                let json = e.target.result;
                Blockly.serialization.workspaces.load(JSON.parse(json.toString()), workspace);
                sessionStorage.setItem("workspace", json.toString());
            };
            reader.readAsText(file);
        };

    }

    start();
</script>
</body>

</html>