<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8">
    <title>WebAudio Test</title>
    <meta name="description" content="WebAudio Test">
    <meta name="author" content="Simon Guest">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        html, body {
            height: 100%;
            margin: 0;
        }
        body {
            background-color: #fff;
            font-family: sans-serif;
            overflow: hidden;
        }
        h1 {
            font-weight: normal;
            font-size: 140%;
        }
        table {
            height: 100%;
            width: 100%;
        }
        #blocklyArea {
            height: 99%;
            background: #ffffff;
            text-align: center;
        }
    </style>
    <script src="./lib/blockly.min.js"></script>
</head>

<body>
<table>
    <tr>
        <td>
            <button id="play">Play</button>
            <button id="pause">Pause</button>
            <button id="resume">Resume</button>
            <button id="stop">Stop</button>
            <button id="debug">Debug</button>
            <button id="clear">Clear Workspace</button>
            <select id="examples">
                <option value="" selected="true">Example Workspaces...</option>
                <option value="bliss.json">Bliss (Mike Harvey)</option>
                <option value="dual.json">Dual Tracks</option>
                <option value="filter.json">Low Pass Filter</option>
            </select>
            <button id="export">Export Workspace</button>
            <input type="file" id="import"/>
        </td>
    </tr>
    <tr>
        <td id="blocklyArea">
            <img src="code-webaudio.png"/>
        </td>
    </tr>
</table>
<div id="blocklyDiv" style="position: absolute"></div>

<script type="module">
    const createCustomBlock = (name, blockType) => {
        Blockly.Blocks[name] = blockType;
        Blockly.JavaScript[name] = blockType["transpile"];
    }

    import * as control from "./blocks/control/index.js";
    import * as percussion from "./blocks/percussion/index.js";
    import * as looping from "./blocks/looping/index.js";
    import * as synths from "./blocks/synths/index.js";
    import { notes } from "./notes.js";
    import {toolbox} from "./blocks/toolbox.js";

    createCustomBlock("track", control.track);
    createCustomBlock("playNote", control.playNote);
    createCustomBlock("playNoteUntilEnd", control.playNoteUntilEnd);
    createCustomBlock("playPianoKey", control.playPianoKey);
    createCustomBlock("playPianoKeyUntilEnd", control.playPianoKeyUntilEnd);
    createCustomBlock("playSample", control.playSample);
    createCustomBlock("playSampleUntilEnd", control.playSampleUntilEnd);
    createCustomBlock("sleep", control.sleepSeconds);
    createCustomBlock("sleepBeats", control.sleepBeats);
    createCustomBlock("volume", control.volume);
    createCustomBlock("filter", control.filter);
    createCustomBlock("bpm", control.bpm);

    createCustomBlock("snare", percussion.snare);
    createCustomBlock("kick", percussion.kick);
    createCustomBlock("hihat", percussion.hihat);
    createCustomBlock("techno", looping.techno);

    createCustomBlock("setSynth", synths.setSynth);
    createCustomBlock("mystic", synths.mystic);
    createCustomBlock("pluck", synths.pluck);
    createCustomBlock("piano", synths.piano);
    createCustomBlock("violin", synths.violin);
    createCustomBlock("customSynth", synths.customSynth);

    var blocklyArea = document.getElementById('blocklyArea');
    var blocklyDiv = document.getElementById('blocklyDiv');
    let workspace = Blockly.inject('blocklyDiv', {
        toolbox: toolbox, move: {
            scrollbars: {
                horizontal: false,
                vertical: true
            },
            drag: true,
            wheel: true
        }
    });
    var onresize = function(e) {
        // Compute the absolute coordinates and dimensions of blocklyArea.
        var element = blocklyArea;
        var x = 0;
        var y = 0;
        do {
            x += element.offsetLeft;
            y += element.offsetTop;
            element = element.offsetParent;
        } while (element);
        // Position blocklyDiv over blocklyArea.
        blocklyDiv.style.left = x + 'px';
        blocklyDiv.style.top = y + 'px';
        blocklyDiv.style.width = blocklyArea.offsetWidth + 'px';
        blocklyDiv.style.height = blocklyArea.offsetHeight + 'px';
        Blockly.svgResize(workspace);
    };
    window.addEventListener('resize', onresize, false);
    onresize();
    Blockly.svgResize(workspace);

    workspace.addChangeListener((ev) => {
        if ((ev.type === Blockly.Events.BLOCK_MOVE) || (ev.type === Blockly.Events.BLOCK_CHANGE) || (ev.type === Blockly.Events.BLOCK_DELETE)) {
            console.log("Writing workspace to session storage");
            let json = Blockly.serialization.workspaces.save(workspace);
            sessionStorage.setItem("workspace", JSON.stringify(json));
        }
    });

    const loadFile = async (filename) => {
        const response = await fetch(filename);
        if (!response.ok) {
            console.error(`HTTP Error: ${response.status}`);
        }
        return await response.arrayBuffer();
    }

    const loadSamples = async (audioContext, filenames) => {
        return new Promise((resolve) => {
            let samples = new Map();
            filenames.forEach(async (filename) => {
                let buffer = await loadFile(filename);
                let decodedBuffer = await audioContext.decodeAudioData(buffer);
                let sampleName = /.+\/(.*).wav/.exec(filename)[1];
                samples.set(sampleName, decodedBuffer);
                console.log(`Added ${sampleName} to audio samples.`);
            });
            resolve(samples);
        });
    }

    const convertToUnitInterval = (value) => {
        // Convert value to fixed point between 0 and 1 for the WebAudio API
        value = Math.abs(value);
        if (value > 100) value = 100;
        return value / 100;
    }

    const highlightBlock = (id) => {
        document.evaluate(`//*[@data-id='${id}']`, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue.classList.add("blocklySelected")
    }

    const removeHighlight = (id) => {
        document.evaluate(`//*[@data-id='${id}']`, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue.classList.remove("blocklySelected")
    }

    const buildGainNodeFromEnvelope = (context, options) => {
        var volume = options.volume || 100;
        const DEFAULT_SYNTH = {
            wave: "sawtooth",
            adsr: {
                attackLevel: 0.8,
                attackDuration: 0.01,
                decayLevel: 0.35,
                decayDuration: 0.1,
                sustainDuration: 0.1,
                releaseDuration: 0.3
            }
        }
        var synth = options.synth || DEFAULT_SYNTH;
        var attackLevel = synth.adsr.attackLevel * (volume / 100);
        var attackDuration = synth.adsr.attackDuration;
        var decayLevel = synth.adsr.decayLevel * (volume / 100);
        var decayDuration = synth.adsr.decayDuration;
        var sustainDuration = synth.adsr.sustainDuration;
        var releaseDuration = synth.adsr.releaseDuration;
        var totalDuration = 0;

        var gainNode = context.createGain();
        gainNode.gain.setValueAtTime(0,0 + context.currentTime + options.offset);
        totalDuration += attackDuration;
        gainNode.gain.linearRampToValueAtTime(attackLevel, totalDuration + context.currentTime + options.offset);
        totalDuration += decayDuration;
        gainNode.gain.linearRampToValueAtTime(decayLevel, totalDuration + context.currentTime + options.offset);
        totalDuration += sustainDuration;
        gainNode.gain.setValueAtTime(decayLevel, totalDuration + context.currentTime + options.offset);
        totalDuration += releaseDuration;
        gainNode.gain.linearRampToValueAtTime(0, totalDuration + context.currentTime + options.offset);

        return { gainNode: gainNode, duration: totalDuration };
    }

    const buildNodeTree = (context, sourceNode, duration, options, blockid) => {
        let volume = options.volume || 100;
        let filter = options.filter || 100;
        let offset = options.offset || 0;

        // highlight the active block
        // null src is an empty source used to highlight the block
        // (to compensate as there is no onStart event handler in WebAudio AudioBufferSourceNode )
        let nullSource = context.createBufferSource();
        if (blockid) {
            sourceNode.onended = () => {
                removeHighlight(blockid);
            }

            nullSource.connect(context.destination);
            nullSource.buffer = context.createBuffer(1, 1, 10000);
            nullSource.onended = () => {
                highlightBlock(blockid);
            }
        }

        // Build the tree backwards, starting with the gain node for volume
        var gainNode;
        if (sourceNode.buffer) {
            // gainnode should be constant level to playback the buffer
            gainNode = context.createGain();
            gainNode.gain.value = convertToUnitInterval(volume)
        } else {
            // gainnode should follow the ADSR envelope defined in the synth
            var output = buildGainNodeFromEnvelope(context, options);
            gainNode = output.gainNode;
            if (output.duration > duration) duration = output.duration;
        }
        gainNode.connect(context.destination);

        // Add the filter node
        var filterNode = context.createBiquadFilter();
        filterNode.type = "lowpass";
        if (sourceNode.buffer) {
            filterNode.frequency.value = (sourceNode.buffer.sampleRate / 4) * convertToUnitInterval(filter);
        }
        console.log(filterNode);
        filterNode.connect(gainNode);
        sourceNode.connect(filterNode);

        // start the source and null source
        sourceNode.start(offset + context.currentTime);
        nullSource.start(offset + context.currentTime);
        if (duration){
            sourceNode.stop(context.currentTime + offset + duration);
        }

    }

    const playSample = (context, samples, name, options, blockid) => {
        let src = context.createBufferSource();
        src.buffer = samples.get(name);
        console.log(src);

        buildNodeTree(context, src, null, options, blockid);

        return src.buffer.duration; // used for play sample until end block
    }

    const playNote = (context, note, duration, options, blockid) => {
        let osc = context.createOscillator();
        osc.type = "sawtooth";
        if (options.synth){
            osc.type = options.synth.wave;
        }
        if (note.freq) {
            osc.frequency.value = note.freq;
        }
        if (note.key) {
            osc.frequency.value = notes[note.key - 1][1];
        }
        console.log(osc);

        buildNodeTree(context, osc, duration, options, blockid);
    }

    const sleep = (context, duration, options, blockid) => {
        // Create a blank sleep source at 10Khz
        let sleepSource = context.createBufferSource();
        sleepSource.connect(context.destination);
        sleepSource.buffer = context.createBuffer(1, duration * 10000, 10000);

        buildNodeTree(context, sleepSource, duration, options, blockid);
        options.offset += duration;
    }

    async function start() {
        console.log("Loading workspace from session storage");
        let jsonStr = sessionStorage.getItem("workspace");
        if (jsonStr) Blockly.serialization.workspaces.load(JSON.parse(jsonStr), workspace);

        let context = new window.AudioContext();
        console.log(context);

        let samples = await loadSamples(context, ["./samples/snare.wav", "./samples/hihat.wav", "./samples/kick.wav", "./samples/techno.wav", "./samples/techno2.wav", "./samples/techno3.wav", "./samples/techno4.wav", "./samples/techno5.wav"]);
        console.log(samples);

        document.getElementById("play").onclick = () => {
            console.log("play button pressed");

            // Generate the required code
            let code = Blockly.JavaScript.workspaceToCode(workspace);
            console.log(code);

            context = new window.AudioContext();
            var options = { bpm: 100, offset: 0};
            eval(code);
        }

        document.getElementById("pause").onclick = () => {
            console.log("pause button pressed");
            context.suspend();
        }

        document.getElementById("resume").onclick = () => {
            console.log("resume button pressed");
            context.resume();
        }

        document.getElementById("stop").onclick = () => {
            console.log("stop button pressed");
            context.close();
        }

        document.getElementById("debug").onclick = () => {
            console.log("debug button pressed");
            context = new window.AudioContext();
            playSample(context, samples, "snare", {});
            playSample(context, samples, "snare", {offset: 0.5});
        }

        document.getElementById("clear").onclick = () => {
            console.log("clear session button pressed");
            if (confirm("Clearing the workspace will lose all unsaved work. Continue?")) {
                sessionStorage.removeItem("workspace");
                location.reload();
            }
        }
        document.getElementById("examples").value = "";
        document.getElementById("examples").onchange = async (e) => {
            console.log("example workspace changed");
            if (e.target.value) {
                if (confirm("Loading this example workspace will lose all unsaved work. Continue?")) {
                    const response = await fetch(`./examples/${e.target.value}`);
                    const json = await response.json();
                    Blockly.serialization.workspaces.load(json, workspace);
                }
            }
        }

        document.getElementById("export").onclick = () => {
            console.log("export workspace button pressed");
            var file = new Blob([sessionStorage.getItem("workspace")], {type: "text/json"});
            var a = document.createElement("a"),
                url = URL.createObjectURL(file);
            a.href = url;
            a.download = "musiclab-workspace.json";
            document.body.appendChild(a);
            a.click();
            setTimeout(function () {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 0);
        }

        document.getElementById("import").onchange = (e) => {
            console.log("importing workspace from file");
            var file = e.target.files[0];
            if (!file) {
                return;
            }
            var reader = new FileReader();
            reader.onload = function (e) {
                var json = e.target.result;
                Blockly.serialization.workspaces.load(JSON.parse(json.toString()), workspace);
                sessionStorage.setItem("workspace", json.toString());
            };
            reader.readAsText(file);
        };

    }

    start();
</script>
</body>

</html>