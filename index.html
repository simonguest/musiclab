<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8">
    <title>WebAudio Test</title>
    <meta name="description" content="WebAudio Test">
    <meta name="author" content="Simon Guest">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        html, body {
            height: 100%;
            margin: 0;
        }
        body {
            background-color: #fff;
            font-family: sans-serif;
            overflow: hidden;
        }
        h1 {
            font-weight: normal;
            font-size: 140%;
        }
        table {
            height: 100%;
            width: 100%;
        }
        #blocklyArea {
            height: 99%;
            background: #e9f5f3;
            text-align: center;
        }
    </style>
    <script src="./lib/blockly.min.js"></script>
</head>

<body>
<table>
    <tr>
        <td>
            <button id="play">Play</button>
            <button id="pause">Pause</button>
            <button id="resume">Resume</button>
            <button id="stop">Stop</button>
            <button id="debug">Debug</button>
            <button id="clear">Clear Workspace</button>
            <button id="export">Export Workspace</button>
            <input type="file" id="import"/>
        </td>
    </tr>
    <tr>
        <td id="blocklyArea">Loading...
        </td>
    </tr>
</table>
<div id="blocklyDiv" style="position: absolute"></div>

<script type="module">
    const createCustomBlock = (name, blockType) => {
        Blockly.Blocks[name] = blockType;
        Blockly.JavaScript[name] = blockType["transpile"];
    }

    import * as control from "./blocks/control/index.js";
    import * as percussion from "./blocks/percussion/index.js";
    import * as looping from "./blocks/looping/index.js";
    import {toolbox} from "./blocks/toolbox.js";

    createCustomBlock("track", control.track);
    createCustomBlock("playNote", control.playNote);
    createCustomBlock("playSample", control.playSample);
    createCustomBlock("playSampleUntilEnd", control.playSampleUntilEnd);
    createCustomBlock("sleep", control.sleepSeconds);
    createCustomBlock("sleepBeats", control.sleepBeats);
    createCustomBlock("volume", control.volume);
    createCustomBlock("filter", control.filter);
    createCustomBlock("bpm", control.bpm);

    createCustomBlock("snare", percussion.snare);
    createCustomBlock("kick", percussion.kick);
    createCustomBlock("hihat", percussion.hihat);
    createCustomBlock("techno", looping.techno);

    var blocklyArea = document.getElementById('blocklyArea');
    var blocklyDiv = document.getElementById('blocklyDiv');
    let workspace = Blockly.inject('blocklyDiv', {
        toolbox: toolbox, move: {
            scrollbars: {
                horizontal: false,
                vertical: true
            },
            drag: true,
            wheel: true
        }
    });
    var onresize = function(e) {
        // Compute the absolute coordinates and dimensions of blocklyArea.
        var element = blocklyArea;
        var x = 0;
        var y = 0;
        do {
            x += element.offsetLeft;
            y += element.offsetTop;
            element = element.offsetParent;
        } while (element);
        // Position blocklyDiv over blocklyArea.
        blocklyDiv.style.left = x + 'px';
        blocklyDiv.style.top = y + 'px';
        blocklyDiv.style.width = blocklyArea.offsetWidth + 'px';
        blocklyDiv.style.height = blocklyArea.offsetHeight + 'px';
        Blockly.svgResize(workspace);
    };
    window.addEventListener('resize', onresize, false);
    onresize();
    Blockly.svgResize(workspace);

    workspace.addChangeListener((ev) => {
        if ((ev.type === Blockly.Events.BLOCK_MOVE) || (ev.type === Blockly.Events.BLOCK_CHANGE) || (ev.type === Blockly.Events.BLOCK_DELETE)) {
            console.log("Writing workspace to session storage");
            let json = Blockly.serialization.workspaces.save(workspace);
            sessionStorage.setItem("workspace", JSON.stringify(json));
        }
    });

    const loadFile = async (filename) => {
        const response = await fetch(filename);
        if (!response.ok) {
            console.error(`HTTP Error: ${response.status}`);
        }
        return await response.arrayBuffer();
    }

    const loadSamples = async (audioContext, filenames) => {
        return new Promise((resolve) => {
            let samples = new Map();
            filenames.forEach(async (filename) => {
                let buffer = await loadFile(filename);
                let decodedBuffer = await audioContext.decodeAudioData(buffer);
                let sampleName = /.+\/(.*).wav/.exec(filename)[1];
                samples.set(sampleName, decodedBuffer);
                console.log(`Added ${sampleName} to audio samples.`);
            });
            resolve(samples);
        });
    }

    const convertToUnitInterval = (value) => {
        // Convert value to fixed point between 0 and 1 for the WebAudio API
        value = Math.abs(value);
        if (value > 100) value = 100;
        return value / 100;
    }

    const highlightBlock = (id) => {
        document.evaluate(`//*[@data-id='${id}']`, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue.classList.add("blocklySelected")
    }

    const removeHighlight = (id) => {
        document.evaluate(`//*[@data-id='${id}']`, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue.classList.remove("blocklySelected")
    }

    const buildNodeTree = (context, sourceNode, duration, options, blockid) => {
        let volume = options.volume || 100;
        let filter = options.filter || 100;
        let offset = options.offset || 0;

        // highlight the active block
        // null src is an empty source used to highlight the block
        // (to compensate as there is no onStart event handler in WebAudio AudioBufferSourceNode )
        let nullSource = context.createBufferSource();
        if (blockid) {
            sourceNode.onended = () => {
                removeHighlight(blockid);
            }

            nullSource.connect(context.destination);
            nullSource.buffer = context.createBuffer(1, 1, 44000);
            nullSource.onended = () => {
                highlightBlock(blockid);
            }
        }

        // Build the tree backwards, starting with the gain node for volume
        var gainNode = context.createGain();
        gainNode.gain.value = convertToUnitInterval(volume);
        gainNode.connect(context.destination);

        // Add the filter node
        var filterNode = context.createBiquadFilter();
        filterNode.type = "lowpass";
        if (sourceNode.buffer) {
            filterNode.frequency.value = (sourceNode.buffer.sampleRate / 4) * convertToUnitInterval(filter);
        }
        console.log(filterNode);
        filterNode.connect(gainNode);
        sourceNode.connect(filterNode);

        // start the source and null source
        sourceNode.start(offset + context.currentTime);
        nullSource.start(offset + context.currentTime);
        if (duration){
            sourceNode.stop(context.currentTime + offset + duration);
        }

    }

    const playSample = (context, samples, name, options, blockid) => {
        options = typeof options !== 'undefined' ? options : {};

        let src = context.createBufferSource();
        src.buffer = samples.get(name);
        console.log(src);

        buildNodeTree(context, src, null, options, blockid);

        return src.buffer.duration; // used for play sample until end block
    }

    const playNote = (context, note, duration, options, blockid) => {
        options = typeof options !== 'undefined' ? options : {};

        let osc = context.createOscillator();
        osc.type = "sine";
        osc.frequency.value = note;
        console.log(osc);

        buildNodeTree(context, osc, duration, options, blockid);
    }

    async function start() {
        console.log("Loading workspace from session storage");
        let jsonStr = sessionStorage.getItem("workspace");
        if (jsonStr) Blockly.serialization.workspaces.load(JSON.parse(jsonStr), workspace);

        let context = new window.AudioContext();
        console.log(context);

        let samples = await loadSamples(context, ["./samples/snare.wav", "./samples/hihat.wav", "./samples/kick.wav", "./samples/techno.wav", "./samples/techno2.wav", "./samples/techno3.wav", "./samples/techno4.wav", "./samples/techno5.wav"]);
        console.log(samples);

        document.getElementById("play").onclick = () => {
            console.log("play button pressed");

            // Generate the required code
            let code = Blockly.JavaScript.workspaceToCode(workspace);
            console.log(code);

            context = new window.AudioContext();
            eval(code);
        }

        document.getElementById("pause").onclick = () => {
            console.log("pause button pressed");
            context.suspend();
        }

        document.getElementById("resume").onclick = () => {
            console.log("resume button pressed");
            context.resume();
        }

        document.getElementById("stop").onclick = () => {
            console.log("stop button pressed");
            context.close();
        }

        document.getElementById("debug").onclick = () => {
            console.log("debug button pressed");
            context = new window.AudioContext();
            playSample(context, samples, "snare", {});
            playSample(context, samples, "snare", {offset: 0.5});
        }

        document.getElementById("clear").onclick = () => {
            console.log("clear session button pressed");
            sessionStorage.removeItem("workspace");
        }

        document.getElementById("export").onclick = () => {
            console.log("export workspace button pressed");
            var file = new Blob([sessionStorage.getItem("workspace")], {type: "text/json"});
            var a = document.createElement("a"),
                url = URL.createObjectURL(file);
            a.href = url;
            a.download = "musiclab-workspace.json";
            document.body.appendChild(a);
            a.click();
            setTimeout(function () {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 0);
        }

        document.getElementById("import").onchange = (e) => {
            console.log("importing workspace from file");
            var file = e.target.files[0];
            if (!file) {
                return;
            }
            var reader = new FileReader();
            reader.onload = function (e) {
                var json = e.target.result;
                Blockly.serialization.workspaces.load(JSON.parse(json.toString()), workspace);
                sessionStorage.setItem("workspace", json.toString());
            };
            reader.readAsText(file);
        };

    }

    start();
</script>
</body>

</html>